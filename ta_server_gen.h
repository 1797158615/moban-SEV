/*
 * File automatically generated by
 * gengen 1.4.2 by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#ifndef TA_SERVER_GEN_CLASS_H
#define TA_SERVER_GEN_CLASS_H

#include <string>
#include <iostream>

using std::string;
using std::ostream;

class ta_server_gen_class
{
 protected:
  string taname_run;

 public:
  ta_server_gen_class()
  {
  }
  
  ta_server_gen_class(const string &_taname_run) :
    taname_run (_taname_run)
  {
  }

  void set_taname_run(const string &_taname_run)
  {
    taname_run = _taname_run;
  }

  void generate_ta_server(ostream &stream, unsigned int indent = 0)
  {
    string indent_str (indent, ' ');
    indent = 0;
  
    stream << "#include <stdio.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <stdlib.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <string.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <sys/socket.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <linux/vm_sockets.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <unistd.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <pthread.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <stdatomic.h>";
    stream << "\n";
    stream << indent_str;
    stream << "#include <fcntl.h>";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "#define VSOCK_PORT 1234";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "atomic_int connection_active = 1; // 标志连接状态";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// Function to handle sending data from host to guest";
    stream << "\n";
    stream << indent_str;
    stream << "void *host_to_guest(void *arg) {";
    stream << "\n";
    stream << indent_str;
    stream << "    int client_fd = *(int *)arg;";
    stream << "\n";
    stream << indent_str;
    stream << "    char buffer[1024];";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Set stdin to non-blocking mode";
    stream << "\n";
    stream << indent_str;
    stream << "    int stdin_fd = fileno(stdin);";
    stream << "\n";
    stream << indent_str;
    stream << "    int flags = fcntl(stdin_fd, F_GETFL, 0);";
    stream << "\n";
    stream << indent_str;
    stream << "    fcntl(stdin_fd, F_SETFL, flags | O_NONBLOCK);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    while (atomic_load(&connection_active)) {";
    stream << "\n";
    stream << indent_str;
    stream << "        // Non-blocking input from stdin";
    stream << "\n";
    stream << indent_str;
    stream << "        if (fgets(buffer, sizeof(buffer), stdin)) {";
    stream << "\n";
    stream << indent_str;
    stream << "            // Send input to guest";
    stream << "\n";
    stream << indent_str;
    stream << "            if (send(client_fd, buffer, strlen(buffer), 0) < 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "                perror(\"send\");";
    stream << "\n";
    stream << indent_str;
    stream << "                break;";
    stream << "\n";
    stream << indent_str;
    stream << "            }";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "        usleep(100000); // Avoid busy-waiting";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "    return NULL;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "// Function to handle receiving data from guest";
    stream << "\n";
    stream << indent_str;
    stream << "void *guest_to_host(void *arg) {";
    stream << "\n";
    stream << indent_str;
    stream << "    int client_fd = *(int *)arg;";
    stream << "\n";
    stream << indent_str;
    stream << "    char buffer[1024];";
    stream << "\n";
    stream << indent_str;
    stream << "    ssize_t n;";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    while (atomic_load(&connection_active)) {";
    stream << "\n";
    stream << indent_str;
    stream << "        n = recv(client_fd, buffer, sizeof(buffer) - 1, 0);";
    stream << "\n";
    stream << indent_str;
    stream << "        if (n > 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "            buffer[n] = '\\0'; // Null-terminate the string";
    stream << "\n";
    stream << indent_str;
    stream << "            printf(\"%s\", buffer); // Print received data";
    stream << "\n";
    stream << indent_str;
    stream << "        } else if (n == 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "            // Connection closed by guest";
    stream << "\n";
    stream << indent_str;
    stream << "            // printf(\"Guest disconnected\\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "            atomic_store(&connection_active, 0);";
    stream << "\n";
    stream << indent_str;
    stream << "            break;";
    stream << "\n";
    stream << indent_str;
    stream << "        } else {";
    stream << "\n";
    stream << indent_str;
    stream << "            perror(\"recv\");";
    stream << "\n";
    stream << indent_str;
    stream << "            break;";
    stream << "\n";
    stream << indent_str;
    stream << "        }";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "    return NULL;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "int main() {";
    stream << "\n";
    stream << indent_str;
    stream << "    //开启服务器";
    stream << "\n";
    stream << indent_str;
    stream << "    int server_fd, client_fd;";
    stream << "\n";
    stream << indent_str;
    stream << "    struct sockaddr_vm addr;";
    stream << "\n";
    stream << indent_str;
    stream << "    socklen_t addr_len = sizeof(addr);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Create VSOCK socket";
    stream << "\n";
    stream << indent_str;
    stream << "    server_fd = socket(AF_VSOCK, SOCK_STREAM, 0);";
    stream << "\n";
    stream << indent_str;
    stream << "    if (server_fd < 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "        perror(\"socket\");";
    stream << "\n";
    stream << indent_str;
    stream << "        exit(EXIT_FAILURE);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Configure address";
    stream << "\n";
    stream << indent_str;
    stream << "    memset(&addr, 0, sizeof(addr));";
    stream << "\n";
    stream << indent_str;
    stream << "    addr.svm_family = AF_VSOCK;";
    stream << "\n";
    stream << indent_str;
    stream << "    addr.svm_cid = VMADDR_CID_ANY; // Bind to any CID";
    stream << "\n";
    stream << indent_str;
    stream << "    addr.svm_port = VSOCK_PORT;    // Listening port";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Bind socket";
    stream << "\n";
    stream << indent_str;
    stream << "    if (bind(server_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "        perror(\"bind\");";
    stream << "\n";
    stream << indent_str;
    stream << "        close(server_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "        exit(EXIT_FAILURE);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Start listening";
    stream << "\n";
    stream << indent_str;
    stream << "    if (listen(server_fd, 1) < 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "        perror(\"listen\");";
    stream << "\n";
    stream << indent_str;
    stream << "        close(server_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "        exit(EXIT_FAILURE);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // printf(\"Waiting for connection...\\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "    //链接虚拟机";
    stream << "\n";
    stream << indent_str;
    stream << "    system(\"ssh -p 10022 root";
    stream << "@";
    stream << "localhost './";
    stream << taname_run;
    stream << "'\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Accept connection";
    stream << "\n";
    stream << indent_str;
    stream << "    client_fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);";
    stream << "\n";
    stream << indent_str;
    stream << "    if (client_fd < 0) {";
    stream << "\n";
    stream << indent_str;
    stream << "        perror(\"accept\");";
    stream << "\n";
    stream << indent_str;
    stream << "        close(server_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "        exit(EXIT_FAILURE);";
    stream << "\n";
    stream << indent_str;
    stream << "    }";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // printf(\"Client connected\\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Create threads for bidirectional communication";
    stream << "\n";
    stream << indent_str;
    stream << "    pthread_t send_thread, recv_thread;";
    stream << "\n";
    stream << indent_str;
    stream << "    pthread_create(&send_thread, NULL, host_to_guest, &client_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "    pthread_create(&recv_thread, NULL, guest_to_host, &client_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Wait for threads to finish";
    stream << "\n";
    stream << indent_str;
    stream << "    pthread_join(recv_thread, NULL); // Wait for guest_to_host to detect disconnection";
    stream << "\n";
    stream << indent_str;
    stream << "    atomic_store(&connection_active, 0); // Ensure send_thread also exits";
    stream << "\n";
    stream << indent_str;
    stream << "    pthread_join(send_thread, NULL);";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
    stream << "    // Cleanup";
    stream << "\n";
    stream << indent_str;
    stream << "    close(client_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "    close(server_fd);";
    stream << "\n";
    stream << indent_str;
    stream << "    // printf(\"Connection closed\\n\");";
    stream << "\n";
    stream << indent_str;
    stream << "    system(\"ssh -p 10022 root";
    stream << "@";
    stream << "localhost 'shutdown -h now'\");";
    stream << "\n";
    stream << indent_str;
    stream << "    return 0;";
    stream << "\n";
    stream << indent_str;
    stream << "}";
    stream << "\n";
    stream << indent_str;
    stream << "\n";
    stream << indent_str;
  }
};

#endif // TA_SERVER_GEN_CLASS_H
